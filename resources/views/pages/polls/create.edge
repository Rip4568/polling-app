@layout.main({ title: "Create new Poll" })
    <main class="container mx-auto p-4 w-sm">
      <form method="POST" class="shadow-md px-8 pt-6 pb-8 mb-4 bg-secondary-dark rounded flex flex-col" name="poll-form" action="{{ route('polls.store') }}">

        {{ csrfField() }}
          {{--  <input type="file" name="banner" accept="image/*" class="rounded border-none px-4 py-2 bg-gray-600 mb-4" placeholder="asd">  --}}
          <input type="text" required value="TITULO QUALQUER AQUI" name="title" placeholder="Title Poll Here..." autocomplete="off" class="rounded border-none px-4 py-2 bg-gray-600 mb-4">
          <input type="text" required value="DESCRIÇÃO QUALQUER AQUI" name="description" placeholder="description Poll Here..." autocomplete="off" class="rounded border-none px-4 py-2 bg-gray-600 mb-4">
          <button class="btn btn-primary" type="submit">Create Poll</button>
      </form>
    </main>
@end

<script>
  window.document.addEventListener('DOMContentLoaded', function (documentEvent) {
    
    async function createPoll(formHtml) {
      const formData = new FormData(formHtml);
  
      // Clear previous error messages
      const existingError = formHtml.querySelector('.error-message');
      if (existingError) existingError.remove();

      const options = [];
      for (let [key, value] of formData.entries()) {
        if (key.startsWith('options option-') && value.trim() !== '') {
          options.push({ title: value.trim() });
        }
      }

      // Client-side validation
      if (options.length < 2) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'bg-red-500 text-white p-4 mb-4 rounded error-message';
        errorDiv.textContent = 'At least 2 options are required';
        formHtml.insertBefore(errorDiv, formHtml.firstChild);
        return;
      }

      const data = {
        title: formData.get('title'),
        description: formData.get('description'),
        deviceIdOwner: navigator.userAgent,
        dateBegin: null,
        dateExpiration: null,
        options: options
      };

      try {
        const response = await fetch("/api/v1/polls/", {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            'Accept': 'application/json',
            'X-CSRF-TOKEN': document.querySelector('input[name="_csrf"]').value
          },
          body: JSON.stringify(data)
        });

        const result = await response.json();
    
        if (!response.ok) {
          throw new Error(result.message || 'Failed to create poll');
        }

        // Success - redirect or show success message
        window.location.href = '/polls'; // Redirect to polls list
    
      } catch (error) {
        const errorDiv = document.createElement('div');
        errorDiv.className = 'bg-red-500 text-white p-4 mb-4 rounded error-message';
        errorDiv.textContent = error.message;
        formHtml.insertBefore(errorDiv, formHtml.firstChild);
      }
    }

    function listnerForm(){
      const formHtml = document.querySelector('form');
      formHtml.addEventListener('submit', async function(event) {
        event.preventDefault();
        const data = await createPoll(formHtml);
      });
    }
    
    listnerForm()
    
    let inputsCounterGenerated = 0;

    function buildInputUploadIcon(className, datasetCounter) {
      const form = document.querySelector('form');
      const input = document.createElement('input');
      input.type = 'file';
      input.name = `icons icon-${datasetCounter}`;
      input.dataset.counter = datasetCounter;
      input.className = `rounded border-none px-4 py-2 bg-gray-600 mb-4 ${className}`;
      return input;
    }

    // Function to create a new input element
    function buildInput(className, datasetCounter) {
      const form = document.querySelector('form');
      const input = document.createElement('input');
      input.type = 'text';
      input.name = `options option-${datasetCounter}`;
      input.placeholder = 'Poll Options...';
      input.autocomplete = 'off';
      input.dataset.counter = datasetCounter;
      input.className = `rounded border-none px-4 py-2 bg-gray-600 mb-4 ${className}`;
      return input;
    }

    // Function to add a new input to the form
    function addNewInput(listner = true) {
      const form = document.querySelector('form');
      const inputs = form.querySelectorAll('input[name*="options"]');
      const counterIncremented = ++inputsCounterGenerated;
      const newClassName = `option-${counterIncremented}`;
      const newInput = buildInput(newClassName, counterIncremented);
      form.insertBefore(newInput, form.querySelector('button'));
      if(listner) {
        listenerLastInput();
      }
    }

    // Function to remove an input from the form
    function deleteInput(className) {
      const input = document.querySelector(`.${className}`);
      if (input) {
        input.remove();
      }
    }

    // Function to add event listener to the last input
    function listenerLastInput() {
      const inputs = document.querySelectorAll('input[name*="options"]');
      const lastInput = inputs[inputs.length - 1];
      
      lastInput.addEventListener('input', function() {
        const inputsUpdated = document.querySelectorAll('input[name*="options"]');
        const myContentLength = this.value.length;
        let myPosition;
        inputsUpdated.forEach((input, index) => {
          if (input.dataset.counter === this.dataset.counter) {
            myPosition = index;
          }
        });        
        
        let iAmTheLast = this.dataset.counter === lastInput.dataset.counter;
        
        const nextInput = inputsUpdated[myPosition + 1];
        
        if (myContentLength > 0 && !nextInput) {
          addNewInput();
        }
        
        if (myContentLength == 0 && !nextInput.value) {
          nextInput.remove()
        }
      });

    }

    // Initialize with one input
    addNewInput(listner=false);
    listenerLastInput();
  });
</script>